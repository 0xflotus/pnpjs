<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>@pnp - SharePoint Patterns and Practices JavaScript Libraries</title>
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <header>
        SharePoint Patters and Practices
    </header>

    <article>
        <h1>@pnp/odata/pipeline</h1>
<p>All of the odata requests processed by @pnp/odata pass through an extensible request pipeline. Each request is executed in a specific request context defined by
the RequestContext&lt;T&gt; interface with the type parameter representing the type ultimately returned at the end a successful processing through the
pipeline. Unless you are writing a pipeline method it is unlikely you will ever interact directly with the request pipeline.</p>
<h2>interface RequestContext&lt;T&gt;</h2>
<p>The interface that defines the context within which all requests are executed. Note that the pipeline methods to be executed are part of the context. This
allows full control over the methods called during a request, and allows for the insertion of any custom methods required.</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">interface</span> RequestContext&lt;T&gt; {
    batch: ODataBatch;
    batchDependency: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">void</span>;
    cachingOptions: ICachingOptions;
    hasResult?: <span class="hljs-built_in">boolean</span>;
    isBatched: <span class="hljs-built_in">boolean</span>;
    isCached: <span class="hljs-built_in">boolean</span>;
    options: FetchOptions;
    parser: ODataParser&lt;T&gt;;
    pipeline: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-function">(<span class="hljs-params">c: RequestContext&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;RequestContext&lt;T&gt;&gt;&gt;;
    requestAbsoluteUrl: <span class="hljs-built_in">string</span>;
    requestId: <span class="hljs-built_in">string</span>;
    result?: T;
    verb: <span class="hljs-built_in">string</span>;
    clientFactory: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> RequestClient;
}
</code></pre>
<h2>requestPipelineMethod decorator</h2>
<p>The requestPipelineMethod decorator is used to tag a pipeline method and add functionality to bypass processing if a result is already present in the pipeline. If you
would like your method to always run regardless of the existance of a result you can pass true to ensure it will always run. Each pipeline method takes a single argument
of the current RequestContext and returns a promise resolving to the RequestContext updated as needed.</p>
<pre><code class="language-TypeScript"><span class="hljs-meta">@requestPipelineMethod</span>(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> myPipelineMethod&lt;T&gt;(context: RequestContext&lt;T&gt;): <span class="hljs-built_in">Promise</span>&lt;RequestContext&lt;T&gt;&gt; {

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>&lt;RequestContext&lt;T&gt;&gt;(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {

        <span class="hljs-comment">// do something</span>

        resolve(context);
    });
}
</code></pre>
<h2>Default Pipeline</h2>
<ol>
<li>logs the start of the request</li>
<li>checks the cache for a value based on the contextâ€™s cache settings</li>
<li>sends the request if no value from found in the cache</li>
<li>logs the end of the request</li>
</ol>

    </article>

    <footer>
        &copy; Microsoft<br />
        Please <a href="https://github.com/pnp/pnp/issues/new?title=Documentation: {your title}&body=Please describe how we can improve the doc page $$OriginalFilePath$$">report documentation issues</a> so we can improve things!
    </footer>
</body>

</html>