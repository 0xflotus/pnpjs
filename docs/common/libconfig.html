<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>@pnp - SharePoint Patterns and Practices JavaScript Libraries</title>
    <link rel="stylesheet" href="/pnpjs/css/highlightjs-github.css">
    <link rel="stylesheet" href="/pnpjs/css/site.css">
</head>

<body>
    <header>
        <span id="headerText">
            <a href="/pnpjs">SharePoint Patterns and Practices</a>
        </span>
        <span id="subheaderText">Client Side Libraries</span>
    </header>

    <nav id="breadcrumbs">
        <a href="/pnpjs">@pnp</a>&nbsp;&nbsp;&gt;&nbsp;&nbsp;<a href="/pnpjs/common">common</a>&nbsp;&nbsp;&gt;&nbsp;&nbsp;<a href="/pnpjs/common/libconfig.html">libconfig</a>
    </nav>

    <article>
        <h1>@pnp/common/libconfig</h1>
<p>Contains the shared classes and interfaces used to configure the libraries. These bases classes are expanded on in dependent libraries with the core
configuration defined here. This module exposes an instance of the RuntimeConfigImpl class: RuntimeConfig. This configuration object can be referenced and
contains the global configuration shared across the libraries. You can also extend the configuration for use within your own applications.</p>
<h2>LibraryConfiguration Interface</h2>
<p>Defines the shared configurable values used across the library as shown below. Each of these has a default value as shown below</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> LibraryConfiguration {

    <span class="hljs-comment">/**
     * Allows caching to be global disabled, default: false
     */</span>
    globalCacheDisable?: <span class="hljs-built_in">boolean</span>;

    <span class="hljs-comment">/**
     * Defines the default store used by the usingCaching method, default: session
     */</span>
    defaultCachingStore?: <span class="hljs-string">"session"</span> | <span class="hljs-string">"local"</span>;

    <span class="hljs-comment">/**
     * Defines the default timeout in seconds used by the usingCaching method, default 30
     */</span>
    defaultCachingTimeoutSeconds?: <span class="hljs-built_in">number</span>;

    <span class="hljs-comment">/**
     * If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval
     */</span>
    enableCacheExpiration?: <span class="hljs-built_in">boolean</span>;

    <span class="hljs-comment">/**
     * Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100)
     */</span>
    cacheExpirationIntervalMilliseconds?: <span class="hljs-built_in">number</span>;

    <span class="hljs-comment">/**
     * Used to supply the current context from an SPFx webpart to the library
     */</span>
    spfxContext?: <span class="hljs-built_in">any</span>;
}
</code></pre>
<h2>RuntimeConfigImpl</h2>
<p>The class which implements the runtime configuration management as well as sets the default values used within the library. At its heart lies a <a href="collections.html">Dictionary</a>
used to track the configuration values. The keys will match the values in the interface or plain object passed to the extend method.</p>
<h3>extend</h3>
<p>The extend method is used to add configuration to the global configuration instance. You can pass it any plain object with string keys and those values will be added. Any
existing values will be overwritten based on the keys. Last value in wins. For a more detailed scenario of using the RuntimeConfig instance in your own application please
see the section below “Using RuntimeConfig within your application”. Note there are no methods to remove/clear the global config as it should be considered fairly static
as frequent updates may have unpredictable side effects as it is a global shared object. Generally it should be set at the start of your application.</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">import</span> { RuntimeConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"@pnp/common"</span>;

<span class="hljs-comment">// add your custom keys to the global configuration</span>
<span class="hljs-comment">// note you can use object hashes as values</span>
RuntimeConfig.extend({
   <span class="hljs-string">"myKey1"</span>: <span class="hljs-string">"value 1"</span>,
   <span class="hljs-string">"myKey2"</span>: {
       <span class="hljs-string">"subKey"</span>: <span class="hljs-string">"sub value 1"</span>,
       <span class="hljs-string">"subKey2"</span>: <span class="hljs-string">"sub value 2"</span>,
   },
});

<span class="hljs-comment">// read your custom values</span>
<span class="hljs-keyword">const</span> v = RuntimeConfig.get(<span class="hljs-string">"myKey1"</span>); <span class="hljs-comment">// "value 1"</span>
</code></pre>
<h2>Using RuntimeConfig within your Application</h2>
<p>If you have a set of properties you will access very frequently it may be desirable to implement your own configuration object and expose those values as properties. To
do so you will need to create an interface for your configration (optional) and a wrapper class for RuntimeConfig to expose your properties</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">import</span> { LibraryConfiguration, RuntimeConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"@pnp/common"</span>;

<span class="hljs-comment">// first we create our own interface by extending LibraryConfiguration. This allows your class to accept all the values with correct type checking. Note, because</span>
<span class="hljs-comment">// TypeScript allows you to extend from multiple interfaces you can build a complex configuration definition from many sub definitions.</span>

<span class="hljs-comment">// create the interface of your properties</span>
<span class="hljs-comment">// by creating this separately you allows others to compose your parts into their own config</span>
<span class="hljs-keyword">interface</span> MyConfigurationPart {

    <span class="hljs-comment">// you can create a grouped definition and access your settings as an object</span>
    <span class="hljs-comment">// keys can be optional or required as defined by your interface</span>
    my?: {
        prop1?: <span class="hljs-built_in">string</span>;
        prop2?: <span class="hljs-built_in">string</span>;
    }

    <span class="hljs-comment">// and/or define multiple top level properties (beware key collision)</span>
    <span class="hljs-comment">// it is good practice to use a unique prefix</span>
    myProp1: <span class="hljs-built_in">string</span>;
    myProp2: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// now create a combined interface</span>
<span class="hljs-keyword">interface</span> MyConfiguration <span class="hljs-keyword">extends</span> LibraryConfiguration, MyConfigurationPart { }


<span class="hljs-comment">// now create a wrapper object and expose your properties</span>
<span class="hljs-keyword">class</span> MyRuntimeConfigImpl {

    <span class="hljs-comment">// exposing a nested property</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> prop1(): TypedHash&lt;<span class="hljs-built_in">string</span>&gt; {

        <span class="hljs-keyword">const</span> myPart = RuntimeConfig.get(<span class="hljs-string">"my"</span>);
        <span class="hljs-keyword">if</span> (myPart !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> myPart !== <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> myPart.prop1 !== <span class="hljs-string">"undefined"</span>) {
            <span class="hljs-keyword">return</span> myPart.prop1;
        }

        <span class="hljs-keyword">return</span> {};
    }

    <span class="hljs-comment">// exposing a root level proeprty</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> myProp1(): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> {

        <span class="hljs-keyword">let</span> myProp1 = RuntimeConfig.get(<span class="hljs-string">"myProp1"</span>);
        
        <span class="hljs-keyword">if</span> (myProp1 === <span class="hljs-literal">null</span>) {
            myProp1 = <span class="hljs-string">"some default value"</span>;
        }

        <span class="hljs-keyword">return</span> myProp1;
    }

    setup(config: MyConfiguration): <span class="hljs-built_in">void</span> {
        RuntimeConfig.extend(config);
    }
}

<span class="hljs-comment">// create a single static instance of your impl class</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> MyRuntimeConfig = <span class="hljs-keyword">new</span> MyRuntimeConfigImpl();
</code></pre>
<p>Now in other files you can use and set your configuration with a typed interface and properties</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">import</span> { MyRuntimeConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"{location of module}"</span>;


MyRuntimeConfig.setup({
    my: {
        prop1: <span class="hljs-string">"hello"</span>,
    },
});

<span class="hljs-keyword">const</span> value = MyRuntimeConfig.prop1; <span class="hljs-comment">// "hello"</span>
</code></pre>

    </article>

    <footer>
        &copy; Microsoft 2018
        <br /> Please
        <a href="https://github.com/pnp/pnpjs/issues/new?title=Documentation: common\libconfig.html&body=Please describe how we can improve the doc page:">report documentation issues/suggestions</a> to help us improve!
    </footer>
</body>

</html><img src="https://telemetry.sharepointpnp.com/@pnp/pnpjs/ghpages/common/docs/libconfig" alt="spacer" />